

## Embedded Graphics
>`embedded` systems mean any system based on an STM32 microcontroller. 
`graphics` means interactive applications with a user interface running at 60 frames per second

## Main loop
### How 'update' works
"If for example a Click event occurs, the graphics engine searches the scene model of the Screen object to find the Widget that should receive the event (the topmost widget below the touch point). Some Widgets like Image and TextArea do not wish to receive Click events, so they are disregarded. They also have an empty event handler."

Where is event handlered?

> The event handlers are virtual functions on the Screen class 

- When requesting a redraw, the area covered by the widget e.g. a button is an invalidated area. the graphic engine keeps a list of these invalidated areas requested for the frame. In the rendering phrase, the render runs throught the list and draw the widgets covering the areas into the framebuffer.
- Typically, the whole frame buffer is transferred to the display even if only a part of the UI is updated. It runs like:
	Update1, Update 2, Update 3, ..., Update N, Transfer to display
 While for a partical frame buffer, it's like this, the engine select one widget and complete its drawing operation in the partical framebuffer and transfer that part to the display. 
Update1, Transfer1, Update2, Transfer2, Update3, Transfer3, ..., UpdateN, TransferN



## mainstream car instrument cluster screeen frame rates
Tesla's instrument cluster screens (Model S/X) operate at 60 Hz.
Mercedes-Benz MBUX clusters typically use 60 Hz OLED or LCD displays.
Budget-friendly digital clusters may still use 30 Hz for cost efficiency.

## Performance
1. use gpio/timer to measuring the rendering timer
1. counting the lost frames

The rendering(drawing) time is generally proportional to the number of the pixels that must be updated.

Rendering cost of elements:

Box < images < text < rotated/scaled images < Geometric elements (like circles)


# Development

## Hardware Selection

How to calculate the maximum fps?

Example
An example of assessing the theoretical core and subsystem performance when running from internal RAM on an STM32H7 can be seen next:

The CPU core is running at 480MHz.
The 64-bit AXI bus frequency at 240MHz.
The LCD-TFT display controller (LTDC) uses the 64-bit AXI bus, and does 8 transfers in 10 cycles.
The internal RAM poses no significant latency, i.e. 0 wait states.
The bandwidth of the internal RAM when accessed by the LTDC peripheral is then:

Bandwidth = 240 MHz x 8/10 x 8 bytes = 1,536Mbytes/s.
With such bandwidth, the internal RAM can ensure 1000 frames per second (fps) for 800x480 resolution at 32bpp color depth. Typically one would limit the transfer to the display (by adjusting pixel clock, porches, ...) to 60 frames per second, so the bandwidth of the LTDC and internal RAM is not a bottleneck.


## 2. CPU running tests
- read the flash from 0x08000000 to 0x08020000 (128 Kb) and time the code.
On a 16 MHz STM32F429 the code runs in 12 ms giving us a read speed of the internal flash (using this method) of 128kb/0.012s = 10,666 kb/s.



## TouchGFX AL Development

TouchGFX Generator is a part of X-CUBE-TOUCHGFX, a CubeMX additional component, is used to create the AL: TouchGFX HAL + TouchGFX OSAL + TouchGFX Configuration. 

Resources of this part.

### display interface
OSAL do: OSWrappers::signalVSync(), it signals the semaphore to the engine;
 OSWrappers::waitForVSync() is called by Engine after a rendering is complete ( to yeild cpu to other tasks). 

### TouchController interface 
Engine translate the XY cooridnates into `click-, drag- and gesture events` to application.

A `STM32TouchController` class is generated by the Generator.
### ButtonController interface
A `ButtonController ` class is created.

When rendering an image the Engine checks if the HAL eg DMA2D can do the drawing job first. If so, the drawing operation is delegated to the HAL rather than being handled by the CPU.


## Software develoment

- Model class is a singleton class. always alive.
- ModelListener interface in application.
- View class, derives from TouchGFX View class. contains `setupScreen()` and `tearDownScreen()` function called when this screen is entered/exited. contains a poiter to the associated Presenter. 
- Prenenter class, (TouchGFX Prensenter), is responsible for the business logic of this screen. eg. it receives an alarm 'backend' event from the Model and tell the View to popup a dialog to display. 


### Code structure
- The `gui_generated` code serves as base(father) calsses for user code classes.
- User code files are only generated if not present. 

##################################################################
Appendixs


## Names
1. `LTDC` =  LCD-TFT Display Controller.
1. `Chrom-ART` = DMA2D or 2D DMA, naming is arbitary.  Its hardware can do Color filling, Image copying, Pixel format conversion, Alpha blending.
1. `FMC` = Flexible Memory controller
1. `FSMC` = Flexible Static Memory Controller
1. `MIPI` = (Mobile Industry Processor Interface) 
	MIPI DSI = Display Serial interface
	MIPI CSI = Camera Serial Interface
1. `AL` = Abstraction Layer 
1. `application` = screens, widgets
1. `Data Reader` = serial flash, a non-memory mapped flash
	
## DO and DON'T quick facts
- Does NOT support multiple touch.
- You should expect that this Bring-up phase will take some days to complete.
- Bring-up does NOT involve any TouchGFX code.
- CubeMX generate : 1. startup code to MCU 2. interrupt table, 3 system initialization code, 4 HAL drivers for all the peripherals in the MCU. 5. linker script
- It's better to disable the data cache in bringing-up phase when you have not got a stable platform. (it can be disabled in CubeMX in the System Core section).
- Layers are numbered 1, 2 in the HAL functions, but 0, 1 in STM32CubeMX. stupid.

## Resources
- CubeIDE All: https://www.st.com/en/development-tools/stm32cubeide.html#documentation
